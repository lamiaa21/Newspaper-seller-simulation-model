# -*- coding: utf-8 -*-
"""simP2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13pE4i7HO2bVkdMTWqWr0I2-VY0mN1nBX
"""

import random as rd
import numpy as np
from prettytable import PrettyTable
import matplotlib.pyplot as plt
import seaborn as sns

# Generate type of Newsday


def generate_type(r):
    if r >= 0 and r <= 18:
        d = "E"
    elif r > 18 and r <= 60:
        d = "G"
    elif r > 60 and r <= 92:
        d = "F"
    elif r > 92 and r <= 100:
        d = "P"
    return d


# Generate demand for excellent Newsdays
def generate_ex(r):
    if r == 0:
        d = 40
    elif r > 0 and r <= 7:
        d = 50
    elif r > 7 and r <= 15:
        d = 60
    elif r > 15 and r <= 27:
        d = 70
    elif r > 27 and r <= 40:
        d = 80
    elif r > 40 and r <= 62:
        d = 90
    elif r > 62 and r <= 85:
        d = 100
    elif r > 85 and r <= 93:
        d = 110
    elif r > 93 and r <= 100:
        d = 120
    return d


# Generate demand for good Newsdays


def generate_go(r):
    if r >= 0 and r <= 6:
        d = 40
    elif r > 6 and r <= 15:
        d = 50
    elif r > 15 and r <= 31:
        d = 60
    elif r > 31 and r <= 50:
        d = 70
    elif r > 50 and r <= 78:
        d = 80
    elif r > 78 and r <= 90:
        d = 90
    elif r > 90 and r <= 97:
        d = 100
    elif r > 97 and r <= 100:
        d = 110
    return d


# Generate demand for fair Newsdays


def generate_fa(r):
    if r >= 0 and r <= 15:
        d = 40
    elif r > 15 and r <= 37:
        d = 50
    elif r > 37 and r <= 65:
        d = 60
    elif r > 65 and r <= 83:
        d = 70
    elif r > 83 and r <= 93:
        d = 80
    elif r > 93 and r <= 98:
        d = 90
    elif r > 98 and r <= 100:
        d = 100
    return d


# Generate demand for poor Newsdays


def generate_po(r):
    if r >= 0 and r <= 42:
        d = 40
    elif r > 42 and r <= 70:
        d = 50
    elif r > 70 and r <= 84:
        d = 60
    elif r > 84 and r <= 94:
        d = 70
    elif r > 94 and r <= 99:
        d = 80
    elif r > 99 and r <= 100:
        d = 90
    return d


typ = []
demand = []
revenue = []
cost = []
lostP_x = []
salvage = []
Dprofit = []
purchase = []
Profits = []
optimal = []
randTyp = []
randDnd = []

n = int(input("Enter number of days: "))
price_P = float(input("Enter Purchase Price: "))
price_S = float(input("Enter Sell Price: "))
scrap = float(input("Enter Scrap Price: "))
# n=10
# price_P=0.5
# price_S=0.7
# scrap=0.15


# to loop on bundles

for i in range(40, 150, 20):
    optimal.append(i)

    # to loop on days
    for j in range(0, n, 1):
        r = rd.uniform(0, 100)
        randTyp.append(r)
        typ.append(generate_type(r))
        r1 = rd.uniform(0, 100)
        randDnd.append(r1)
        if typ[j] == "E":
            demand.append(generate_ex(r1))
        elif typ[j] == "G":
            demand.append(generate_go(r1))
        elif typ[j] == "F":
            demand.append(generate_fa(r1))
        elif typ[j] == "P":
            demand.append(generate_po(r1))
        purchase.append(i)
        revenue.append(demand[j] * price_S)
        cost.append(i * price_P)
        if demand[j] > i:
            lostP_x.append((demand[j] - i) * price_S)  # Fix: Use selling price
            salvage.append(0)
        else:
            lostP_x.append(0)
            salvage.append(
                (i - demand[j]) * scrap
            )  # No lost profit if demand <= supply
        Dprofit.append(revenue[j] - cost[j] - lostP_x[j] + salvage[j])

    # Caluculations

    print("\nfor purchase: ", i)
    Profits.append(sum(Dprofit))
    avgProfit = sum(Dprofit) / n
    print("sum profit: ", "%.2f" % sum(Dprofit))
    print("average ptofit: ", "%.2f" % avgProfit)

    # print the calender

    t = PrettyTable(
        [
            "Day",
            "purchase",
            "rand for type",
            "Type",
            "rand for demand",
            "demand",
            "revenue from sales",
            "cost",
            "lost profit from excess demand",
            "salvage from sale of scrap",
            "Daily profit",
        ]
    )
    for k in range(n):
        t.add_row(
            [
                k + 1,
                purchase[k],
                int(randTyp[k]),
                typ[k],
                int(randDnd[k]),
                demand[k],
                "%.2f" % revenue[k],
                "%.2f" % cost[k],
                "%.2f" % lostP_x[k],
                "%.2f" % salvage[k],
                "%.2f" % Dprofit[k],
            ]
        )
    print(t)

    print("\n")
    print(
        "---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------"
    )
    print("\n")
    print("\n")

    # Graphs
    # plt.title('Types of Newsdays')
    # plt.xlabel('type')
    # plt.ylabel('frequency')
    # plt.hist(typ, color='purple')
    # plt.show()

    # plt.title('Demand')
    # plt.xlabel('Demand')
    # plt.ylabel('Frequency')
    # plt.hist(demand)
    # plt.show()

    # plt.title('Lost Profit From Demand')
    # plt.xlabel('Lost')
    # plt.ylabel('Frequency')
    # plt.hist(lostP_x, color='red')
    # plt.show()

    # plt.title('Salvage')
    # plt.xlabel('Salvage')
    # plt.ylabel('Frequency')
    # plt.hist(salvage, color='blue')
    # plt.show()

    # plt.title('Loss')
    # plt.xlabel('Loss')
    # plt.ylabel('Frequency')
    # plt.hist(salvage, color='c')
    # plt.show()

    # plt.title('Daily Profits')
    # plt.xlabel('Days')
    # plt.ylabel('Profit')
    # plt.plot(Dprofit, color='c')
    # plt.show()

    # clear all the arrays from data to begin another calender
    typ.clear()
    demand.clear()
    purchase.clear()
    revenue.clear()
    cost.clear()
    salvage.clear()
    lostP_x.clear()
    Dprofit.clear()
    randDnd.clear()
    randTyp.clear()

# Determine the optimal number of papers the seller should purchase to increase his profit.
maxProfit = max(Profits)
print("\n\nthe max profit: ", "%.2f" % maxProfit)
optIdx = Profits.index(maxProfit)
first_optimal = optimal[optIdx]
print(
    "the optimal number of newspaper that the seller should purchase is: ",
    optimal[optIdx],
)


# plot between purchase and maximum profits

plt.title("purchase profit")
plt.xlabel("purchase")
plt.ylabel("profit")
plt.plot(optimal, Profits)
plt.show()

# bar graph between optimal purchase and maximum profit

plt.title("Optimal for Profits")
plt.xlabel("Max Profit")
plt.ylabel("Optimal")
plt.bar(Profits, optimal, color="c", width=10)
plt.show()

optimal.clear()
Profits.clear()

"""### **How does the price of selling the newspaper and of selling the unsold newspapers as a scrap affect ?**

"""

# Amount of Increasing Sell Price
AOI_sell = float(input("Enter the amount of increasing the selling Price: "))
# Amount of Increasing Scrap Price
AOI_scrap = float(input("Enter the amount of increasing the scrap Price: "))
price_S += AOI_sell
scrap += AOI_scrap
# to loop on bundles
for i in range(40, 150, 20):
    optimal.append(i)

    # to loop on days
    for j in range(0, n, 1):
        r = rd.uniform(0, 100)
        randTyp.append(r)
        typ.append(generate_type(r))
        r1 = rd.uniform(0, 100)
        randDnd.append(r1)
        if typ[j] == "E":
            demand.append(generate_ex(r1))
        elif typ[j] == "G":
            demand.append(generate_go(r1))
        elif typ[j] == "F":
            demand.append(generate_fa(r1))
        elif typ[j] == "P":
            demand.append(generate_po(r1))
        purchase.append(i)
        revenue.append(demand[j] * price_S)
        cost.append(i * price_P)
        if demand[j] > i:
            lostP_x.append((demand[j] - i) * price_S)  # Fix: Use selling price
            salvage.append(0)
        else:
            lostP_x.append(0)
            salvage.append(
                (i - demand[j]) * scrap
            )  # No lost profit if demand <= supply
        Dprofit.append(revenue[j] - cost[j] - lostP_x[j] + salvage[j])

    # Caluculations

    print("\nfor purchase: ", i)
    Profits.append(sum(Dprofit))
    avgProfit = sum(Dprofit) / n
    print("sum profit: ", "%.2f" % sum(Dprofit))
    print("average ptofit: ", "%.2f" % avgProfit)

    # print the calender
    t = PrettyTable(
        [
            "Day",
            "purchase",
            "rand for type",
            "Type",
            "rand for demand",
            "demand",
            "revenue from sales",
            "cost",
            "lost profit from excess demand",
            "salvage from sale of scrap",
            "Daily profit",
        ]
    )
    for k in range(n):
        t.add_row(
            [
                k + 1,
                purchase[k],
                int(randTyp[k]),
                typ[k],
                int(randDnd[k]),
                demand[k],
                "%.2f" % revenue[k],
                "%.2f" % cost[k],
                "%.2f" % lostP_x[k],
                "%.2f" % salvage[k],
                "%.2f" % Dprofit[k],
            ]
        )
    print(t)
    print("\n")
    print(
        "---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------"
    )
    print("\n")
    print("\n")

    # Graphs
    # plt.title('Types of Newsdays')
    # plt.xlabel('type')
    # plt.ylabel('frequency')
    # plt.hist(typ, color='purple')
    # plt.show()

    # plt.title('Demand')
    # plt.xlabel('Demand')
    # plt.ylabel('Frequency')
    # plt.hist(demand)
    # plt.show()

    # plt.title('Lost Profit From Demand')
    # plt.xlabel('Lost')
    # plt.ylabel('Frequency')
    # plt.hist(lostP_x, color='red')
    # plt.show()

    # plt.title('Salvage')
    # plt.xlabel('Salvage')
    # plt.ylabel('Frequency')
    # plt.hist(salvage, color='blue')
    # plt.show()

    # plt.title('Loss')
    # plt.xlabel('Loss')
    # plt.ylabel('Frequency')
    # plt.hist(salvage, color='c')
    # plt.show()

    # plt.title('Daily Profits')
    # plt.xlabel('Days')
    # plt.ylabel('Profit')
    # plt.plot(Dprofit, color='c')
    # plt.show()

    # clear all the arrays from data to begin another calender
    typ.clear()
    demand.clear()
    purchase.clear()
    revenue.clear()
    cost.clear()
    salvage.clear()
    lostP_x.clear()
    Dprofit.clear()
    randDnd.clear()
    randTyp.clear()


# Determine the optimal number of papers the seller should purchase to increase his profit.
maxProfit = max(Profits)
print("\n\nthe max profit: ", "%.2f" % maxProfit)
optIdx = Profits.index(maxProfit)
second_optimal = optimal[optIdx]
if second_optimal > first_optimal:
    print(
        "if you increase the price of selling newspaper by 25 cent and price of selling the extra newspaper by 10 cent"
    )
    print(
        "your optimal number of newspaper that you should purchase will be : ",
        optimal[optIdx],
    )
elif second_optimal < first_optimal:
    print(
        "the increasing of price  of selling newspaper by 25 cent and price of selling the extra newspaper by 10 cent will decreasethe optimal number : ",
        second_optimal,
    )
else:
    print(
        "the increasing of price  of selling newspaper by 25 cent and price of selling the extra newspaper by 10 cent will not affect your optimal number : ",
        second_optimal,
    )


# plot between purchase and maximum profits

plt.title("purchase profit")
plt.xlabel("purchase")
plt.ylabel("profit")
plt.plot(optimal, Profits)
plt.show()

# bar graph between optimal purchase and maximum profit

plt.title("Optimal for Profits")
plt.xlabel("Max Profit")
plt.ylabel("Optimal")
plt.bar(Profits, optimal, color="c", width=10)
plt.show()


# clear optimal and profits lists from data to begin another calender

optimal.clear()
Profits.clear()
price_S -= AOI_sell
scrap -= AOI_scrap

"""### **How does the size of bundle used to purchase newspapers affect ?**

"""

# to loop on bundles

for i in range(40, 150, 10):
    optimal.append(i)

    # to loop on days

    for j in range(0, n, 1):
        r = rd.uniform(0, 100)
        randTyp.append(r)
        typ.append(generate_type(r))
        r1 = rd.uniform(0, 100)
        randDnd.append(r1)
        if typ[j] == "E":
            demand.append(generate_ex(r1))
        elif typ[j] == "G":
            demand.append(generate_go(r1))
        elif typ[j] == "F":
            demand.append(generate_fa(r1))
        elif typ[j] == "P":
            demand.append(generate_po(r1))
        purchase.append(i)
        revenue.append(demand[j] * price_S)
        cost.append(i * price_P)
        if demand[j] > i:
            lostP_x.append((demand[j] - i) * price_S)  # Fix: Use selling price
            salvage.append(0)
        else:
            lostP_x.append(0)
            salvage.append(
                (i - demand[j]) * scrap
            )  # No lost profit if demand <= supply
        Dprofit.append(revenue[j] - cost[j] - lostP_x[j] + salvage[j])

    # Calculations
    print("\nfor purchase: ", i)
    Profits.append(sum(Dprofit))
    avgProfit = sum(Dprofit) / n
    print("sum profit: ", "%.2f" % sum(Dprofit))
    print("average ptofit: ", "%.2f" % avgProfit)

    # print the calender
    t = PrettyTable(
        [
            "Day",
            "purchase",
            "rand for type",
            "Type",
            "rand for demand",
            "demand",
            "revenue from sales",
            "cost",
            "lost profit from excess demand",
            "salvage from sale of scrap",
            "Daily profit",
        ]
    )
    for k in range(n):
        t.add_row(
            [
                k + 1,
                purchase[k],
                int(randTyp[k]),
                typ[k],
                int(randDnd[k]),
                demand[k],
                "%.2f" % revenue[k],
                "%.2f" % cost[k],
                "%.2f" % lostP_x[k],
                "%.2f" % salvage[k],
                "%.2f" % Dprofit[k],
            ]
        )
    print(t)
    print("\n")
    print(
        "---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------"
    )
    print("\n")
    print("\n")

    # Graphs

    # clear all the arrays from data to begin another calender
    typ.clear()
    demand.clear()
    purchase.clear()
    revenue.clear()
    cost.clear()
    salvage.clear()
    lostP_x.clear()
    Dprofit.clear()
    randDnd.clear()
    randTyp.clear()


# Determine the optimal number of papers the seller should purchase to increase his profit.
maxProfit = max(Profits)
print("\n\nthe max profit: ", "%.2f" % maxProfit)
optIdx = Profits.index(maxProfit)
third_optimal = optimal[optIdx]
if third_optimal > first_optimal:
    print(
        "changing the size of bundle to 10 will change the optimal number to: ",
        third_optimal,
    )
elif third_optimal < first_optimal:
    print(
        "changing the size of bundle to 10 will decrease the optimal number to:  ",
        third_optimal,
    )
else:
    print(
        "changing the size of bundle to 10 will not affect the optimal number : ",
        third_optimal,
    )


# plot between purchase and maximum profits

plt.title("purchase profit")
plt.xlabel("purchase")
plt.ylabel("profit")
plt.plot(optimal, Profits)
plt.show()

# bar graph between optimal purchase and maximum profit

plt.title("Optimal for Profits")
plt.xlabel("Max Profit")
plt.ylabel("Optimal")
plt.bar(Profits, optimal, color="c", width=10)
plt.show()

# clear optimal and profits lists from data to begin another calender

optimal.clear()
Profits.clear()
